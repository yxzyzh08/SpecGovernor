# **üèóÔ∏è Design Document - SpecGovernor**

> **Version**: v2.0
> **Based on**: PRD.md (v2.0) + RD.md (v2.0)
> **Created**: 2025-11-16
> **Updated**: 2025-11-16
> **Design Goal**: Detailed design for toolkit components (prompt templates, workflows, helper scripts)

---

## **Traceability Declaration**

This document designs the following PRD features:
- [Designs-for: PRD-FEAT-TEMPLATES-001] Prompt Templates
- [Designs-for: PRD-FEAT-WORKFLOWS-001] Workflow Documentation
- [Designs-for: PRD-FEAT-SCRIPTS-001] Helper Scripts
- [Designs-for: PRD-FEAT-SMALL-001] Small Project Support
- [Designs-for: PRD-FEAT-LARGE-001] Large Project Support

---

## **‰∏Ä„ÄÅToolkit Architecture**

### **1.1 Overall Structure**

**[ID: DESIGN-ARCH-001] [Designs-for: PRD-STRUCTURE-001]**

```
SpecGovernor Repository/
‚îú‚îÄ‚îÄ .specgov/                     # Generated during init (not in repo)
‚îÇ   ‚îú‚îÄ‚îÄ prompts/                  # Copied from templates/
‚îÇ   ‚îú‚îÄ‚îÄ workflows/                # Copied from templates/
‚îÇ   ‚îú‚îÄ‚îÄ tasks/                    # Generated task files
‚îÇ   ‚îú‚îÄ‚îÄ index/                    # Generated by scripts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tags.json
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dependency-graph.json
‚îÇ   ‚îî‚îÄ‚îÄ project-config.json       # Generated configuration
‚îÇ
‚îú‚îÄ‚îÄ templates/                    # Source templates (in repo)
‚îÇ   ‚îú‚îÄ‚îÄ prompts/                  # All prompt template .md files
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rd-generator.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rd-reviewer.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ prd-generator.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ prd-reviewer.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ design-generator.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ design-reviewer.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test-plan-generator.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test-plan-reviewer.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ code-generator.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rd-overview-generator.md      # For large projects
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rd-module-generator.md        # For large projects
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ... (similar for other stages)
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ workflows/                # All workflow documentation
‚îÇ       ‚îú‚îÄ‚îÄ workflow-overview.md
‚îÇ       ‚îú‚îÄ‚îÄ workflow-rd.md
‚îÇ       ‚îú‚îÄ‚îÄ workflow-prd.md
‚îÇ       ‚îú‚îÄ‚îÄ workflow-design.md
‚îÇ       ‚îú‚îÄ‚îÄ workflow-test-plan.md
‚îÇ       ‚îú‚îÄ‚îÄ workflow-task-mgmt.md
‚îÇ       ‚îî‚îÄ‚îÄ workflow-large-project.md
‚îÇ
‚îú‚îÄ‚îÄ scripts/                      # Helper Python scripts
‚îÇ   ‚îú‚îÄ‚îÄ init_project.py
‚îÇ   ‚îú‚îÄ‚îÄ parse_tags.py
‚îÇ   ‚îú‚îÄ‚îÄ build_graph.py
‚îÇ   ‚îî‚îÄ‚îÄ impact_analysis.py
‚îÇ
‚îú‚îÄ‚îÄ docs/                         # Generated documentation (user's project)
‚îÇ   ‚îú‚îÄ‚îÄ RD.md                     # (or RD/ for large projects)
‚îÇ   ‚îú‚îÄ‚îÄ PRD.md                    # (or PRD/ for large projects)
‚îÇ   ‚îú‚îÄ‚îÄ Design-Document.md        # (or Design-Document/ for large)
‚îÇ   ‚îî‚îÄ‚îÄ Test-Plan.md              # (or Test-Plan/ for large)
‚îÇ
‚îî‚îÄ‚îÄ README.md                     # SpecGovernor toolkit documentation
```

**Key Principles:**
- **Templates are source** - Stored in `templates/` directory in repo
- **`.specgov/` is generated** - Created during project initialization
- **No software to install** - Just download repo and run scripts
- **Git-trackable** - All changes to templates, workflows, scripts versioned

---

### **1.2 Component Design**

**[ID: DESIGN-COMP-001]**

| Component Type | Format | Storage Location | Purpose |
|---------------|--------|-----------------|---------|
| **Prompt Templates** | Markdown (.md) | `templates/prompts/` | Guide Claude Code to generate/review documents |
| **Workflow Docs** | Markdown (.md) | `templates/workflows/` | Step-by-step guides for humans |
| **Helper Scripts** | Python (.py) | `scripts/` | Automate tag parsing, graph building, impact analysis |
| **Task Files** | Markdown (.md) | `.specgov/tasks/` | Track Epics and Tasks (generated, user-edited) |
| **Index Files** | JSON (.json) | `.specgov/index/` | Store parsed tags and dependency graph (generated) |

---

## **‰∫å„ÄÅPrompt Template Design**

### **2.1 General Template Structure**

**[ID: DESIGN-TEMPLATE-STRUCT-001] [Designs-for: PRD-FEAT-TEMPLATES-001]**

All prompt templates follow this structure:

```markdown
# [Document Type] Generator / Reviewer

## Role
You are a [role name] (e.g., Requirements Analyst, Architect, Test Manager).

## Task
[Generate/Review] [document type] based on provided inputs.

## Critical Requirements

### 1. Traceability Tags
- MUST embed tags in every section:
  - [ID: XXX] - Unique identifier
  - [Implements: XXX] / [Designs-for: XXX] / [Tests-for: XXX] - Link to upstream

### 2. Document Structure
[Specific structure for this document type]

### 3. Naming Conventions
- Use proper terminology: "Design Document" (not "DD"), "Test Plan" (not "TD")
- ID prefixes: RD-XXX, PRD-XXX, DESIGN-XXX, TEST-XXX, CODE-XXX

## Input Format
[What inputs the user should provide]

## Output Format
[Detailed structure, with examples]

## Examples
[Concrete examples showing proper tag usage]

## Validation Checklist
- [ ] All major sections have [ID: XXX] tags
- [ ] All references to upstream documents use proper tags
- [ ] Proper terminology used throughout
- [ ] ... (specific to document type)
```

---

### **2.2 RD Generator Template**

**[ID: DESIGN-TEMPLATE-RD-GEN-001] [Designs-for: PRD-FEAT-TEMPLATES-001]**

**File**: `templates/prompts/rd-generator.md`

**Key Sections:**

```markdown
# Requirements Document (RD) Generator

## Role
You are an experienced Requirements Analyst.

## Task
Generate or modify a Requirements Document (RD) based on user stories, business requirements, or existing RD.md.

## Critical Requirements

### 1. Traceability Tags
- Every requirement MUST have: **[ID: RD-REQ-XXX]** or **[ID: RD-{CATEGORY}-XXX]**
- Hierarchical requirements use: **[Decomposes: PARENT-ID]**

### 2. Document Structure
# Requirements Document (RD)

> **Version**: X.X
> **Created**: YYYY-MM-DD
> **Updated**: YYYY-MM-DD

## 1. [Category] Requirements
**[ID: RD-CATEGORY-001]**

### 1.1 [Specific Requirement]
**[ID: RD-REQ-001] [Decomposes: RD-CATEGORY-001]**

[Requirement description with clear acceptance criteria]

### 3. Large Project Support
- For large projects (‚â• 100K LOC), use module-specific IDs:
  - **[ID: RD-User-REQ-001] [Module: User]**
  - **[ID: RD-Order-REQ-001] [Module: Order]**

## Input Format
1. If CREATING new RD:
   - User stories
   - Business requirements
   - Project context

2. If MODIFYING existing RD:
   - Existing RD.md content
   - Change requests
   - Feedback from review

## Output Format
Markdown file with:
- Clear hierarchical structure
- Every requirement tagged with [ID: XXX]
- Decomposition tags where appropriate
- Acceptance criteria for each requirement

## Examples

### Example 1: User Authentication Requirement

## 1. User Authentication Requirements
**[ID: RD-AUTH-001]**

This section defines all authentication and authorization requirements.

### 1.1 OAuth2 Login Support
**[ID: RD-REQ-005] [Decomposes: RD-AUTH-001]**

The system must support user authentication via OAuth2 protocol.

**Supported Providers:**
- Google OAuth2
- GitHub OAuth2
- Microsoft OAuth2

**Acceptance Criteria:**
- ‚úÖ User can log in using any supported OAuth2 provider
- ‚úÖ System retrieves user profile information (name, email, avatar)
- ‚úÖ System handles login failures gracefully
- ‚úÖ System handles token expiration and refreshes tokens

## Validation Checklist
Before outputting, verify:
- [ ] Every major requirement has [ID: RD-XXX]
- [ ] Hierarchical requirements use [Decomposes: XXX]
- [ ] Acceptance criteria clearly defined
- [ ] No placeholders or TODOs left
- [ ] For large projects, [Module: XXX] tags present
```

---

### **2.3 PRD Generator Template**

**[ID: DESIGN-TEMPLATE-PRD-GEN-001] [Designs-for: PRD-FEAT-TEMPLATES-001]**

**File**: `templates/prompts/prd-generator.md`

**Key Sections:**

```markdown
# Product Requirements Document (PRD) Generator

## Role
You are an experienced Product Manager.

## Task
Generate or modify a Product Requirements Document (PRD) based on RD.md and product vision.

## Critical Requirements

### 1. Traceability Tags
- Every feature MUST have: **[ID: PRD-FEAT-XXX]**
- Every user story MUST have: **[ID: PRD-US-XXX]**
- MUST link to RD: **[Implements: RD-REQ-XXX]**

### 2. Document Structure
# Product Requirements Document (PRD)

> **Version**: X.X
> **Based on**: RD.md (vX.X)

## 1. Product Features

### 1.1 [Feature Name]
**[ID: PRD-FEAT-XXX] [Implements: RD-REQ-XXX]**

#### User Story
> **As** [user type]
> **I want** [goal]
> **So that** [benefit]

#### Acceptance Criteria
- ‚úÖ [Criterion 1]
- ‚úÖ [Criterion 2]

## Input Format
1. RD.md (requirements document)
2. Product vision statement
3. User personas (if available)
4. Existing PRD.md (if modifying)

## Output Format
Markdown file with:
- Product features with [ID: PRD-FEAT-XXX]
- User stories with [ID: PRD-US-XXX]
- [Implements: RD-REQ-XXX] linking each feature to requirements

## Examples

### Example: OAuth2 Login Feature

## 2. Authentication Features

### 2.1 OAuth2 Social Login
**[ID: PRD-FEAT-012] [Implements: RD-REQ-005]**

Enable users to log in using their existing social media accounts.

#### User Story
> **As** a new user
> **I want** to log in using my Google/GitHub/Microsoft account
> **So that** I don't need to create and remember another password

#### Acceptance Criteria
- ‚úÖ Login button displays for each supported OAuth2 provider
- ‚úÖ Clicking button redirects to provider's OAuth2 authorization page
- ‚úÖ After authorization, user is redirected back and logged in
- ‚úÖ User profile information is displayed in the app
- ‚úÖ If login fails, user sees clear error message

## Validation Checklist
- [ ] Every feature has [ID: PRD-FEAT-XXX]
- [ ] Every feature links to RD with [Implements: RD-REQ-XXX]
- [ ] User stories follow As/I want/So that format
- [ ] Acceptance criteria are testable
```

---

### **2.4 Design Document Generator Template**

**[ID: DESIGN-TEMPLATE-DESIGN-GEN-001] [Designs-for: PRD-FEAT-TEMPLATES-001]**

**File**: `templates/prompts/design-generator.md`

**Key Sections:**

```markdown
# Design Document Generator

## Role
You are an experienced Software Architect.

## Task
Generate or modify a Design Document based on PRD.md and technical constraints.

## Critical Requirements

### 1. Traceability Tags
- Architecture design: **[ID: DESIGN-ARCH-XXX]**
- API design: **[ID: DESIGN-API-XXX]**
- Database design: **[ID: DESIGN-DB-XXX]**
- MUST link to PRD: **[Designs-for: PRD-FEAT-XXX]**

### 2. Terminology
- ALWAYS use "Design Document" (NEVER "DD")
- File name: Design-Document.md (NOT DD.md)

### 3. Document Structure
# Design Document

> **Version**: X.X
> **Based on**: PRD.md (vX.X)

## 1. Architecture Design

### 1.1 [Component Name]
**[ID: DESIGN-ARCH-XXX] [Designs-for: PRD-FEAT-XXX]**

[Architecture description with diagrams]

## 2. API Design

### 2.1 [API Endpoint]
**[ID: DESIGN-API-XXX] [Designs-for: PRD-FEAT-XXX]**

**Endpoint**: [METHOD] /path

**Request:**
```json
{...}
```

**Response:**
```json
{...}
```

## 3. Database Design

### 3.1 [Table/Collection Name]
**[ID: DESIGN-DB-XXX] [Designs-for: PRD-FEAT-XXX]**

## Input Format
1. PRD.md (product requirements)
2. Technical constraints (language, framework, cloud platform, etc.)
3. Existing Design-Document.md (if modifying)

## Output Format
Markdown file with:
- Architecture diagrams and descriptions
- API specifications
- Database schemas
- [Designs-for: PRD-XXX] linking each design to features

## Examples

### Example: OAuth2 API Design

## 2. API Design

### 2.1 OAuth2 Callback Endpoint
**[ID: DESIGN-API-008] [Designs-for: PRD-FEAT-012]**

Handle the OAuth2 callback after user authorizes the application.

**Endpoint**: POST /auth/oauth2/callback

**Request:**
```json
{
  "provider": "google" | "github" | "microsoft",
  "code": "authorization_code_from_provider",
  "redirect_uri": "https://app.example.com/callback"
}
```

**Response (Success):**
```json
{
  "access_token": "eyJhbGc...",
  "refresh_token": "def50200...",
  "expires_in": 3600,
  "user": {
    "id": "user-uuid",
    "email": "user@example.com",
    "name": "John Doe"
  }
}
```

**Response (Error):**
```json
{
  "error": "invalid_grant",
  "error_description": "Invalid authorization code"
}
```

**Implementation Notes:**
- Validate provider is supported
- Exchange auth code for access token using provider's OAuth2 API
- Create or update user in database
- Generate JWT for session management

## Validation Checklist
- [ ] All designs have [ID: DESIGN-XXX]
- [ ] All designs link to PRD with [Designs-for: PRD-XXX]
- [ ] API specs include request/response examples
- [ ] Database schemas show all fields
- [ ] ALWAYS use "Design Document" terminology
```

---

### **2.5 Test Plan Generator Template**

**[ID: DESIGN-TEMPLATE-TEST-GEN-001] [Designs-for: PRD-FEAT-TEMPLATES-001]**

**File**: `templates/prompts/test-plan-generator.md`

**Key Sections:**

```markdown
# Test Plan Generator

## Role
You are an experienced Test Manager / QA Engineer.

## Task
Generate or modify a Test Plan based on Design Document and PRD.

## Critical Requirements

### 1. Traceability Tags
- Test cases: **[ID: TEST-CASE-XXX]**
- MUST link to design: **[Tests-for: DESIGN-API-XXX]**
- Can also link to PRD: **[Tests-for: PRD-FEAT-XXX]**

### 2. Terminology
- ALWAYS use "Test Plan" (NEVER "TD")
- File name: Test-Plan.md (NOT TD.md)

### 3. Document Structure
# Test Plan

> **Version**: X.X
> **Based on**: Design-Document.md (vX.X)

## 1. Test Strategy

[Overall testing approach]

## 2. Test Cases

### 2.1 [Feature/Component] Tests
**[ID: TEST-CASE-XXX] [Tests-for: DESIGN-API-XXX]**

#### Test Case: [Scenario Name]
**[ID: TEST-CASE-XXX-001]**

**Preconditions:**
- [Precondition 1]

**Steps:**
1. [Step 1]
2. [Step 2]

**Expected Result:**
- ‚úÖ [Expected outcome 1]

## Input Format
1. Design-Document.md (technical design)
2. PRD.md (product requirements)
3. Existing Test-Plan.md (if modifying)

## Output Format
Markdown file with:
- Test strategy overview
- Detailed test cases with steps and expected results
- [Tests-for: DESIGN-XXX] linking each test to design

## Examples

### Example: OAuth2 API Test Cases

## 5. Authentication API Tests

### 5.1 OAuth2 Callback Endpoint Tests
**[ID: TEST-CASE-015] [Tests-for: DESIGN-API-008]**

#### Test Case: Successful Google OAuth2 Login
**[ID: TEST-CASE-015-001]**

**Preconditions:**
- User has a valid Google account
- Application is registered with Google OAuth2
- User has authorized the application

**Steps:**
1. Send POST /auth/oauth2/callback with valid Google authorization code:
   ```json
   {
     "provider": "google",
     "code": "valid_auth_code",
     "redirect_uri": "https://app.example.com/callback"
   }
   ```
2. Verify response status is 200
3. Verify response contains access_token
4. Verify response contains refresh_token
5. Verify response contains user object with id, email, name

**Expected Result:**
- ‚úÖ Status: 200 OK
- ‚úÖ access_token: valid JWT (can be decoded, not expired)
- ‚úÖ refresh_token: valid string
- ‚úÖ expires_in: 3600 seconds
- ‚úÖ user.email: matches Google account email

#### Test Case: Invalid Authorization Code
**[ID: TEST-CASE-015-002]**

**Preconditions:**
- None

**Steps:**
1. Send POST /auth/oauth2/callback with invalid authorization code:
   ```json
   {
     "provider": "google",
     "code": "invalid_code",
     "redirect_uri": "https://app.example.com/callback"
   }
   ```
2. Verify response status is 400
3. Verify error message is clear

**Expected Result:**
- ‚úÖ Status: 400 Bad Request
- ‚úÖ error: "invalid_grant"
- ‚úÖ error_description: "Invalid authorization code"

## Validation Checklist
- [ ] All test cases have [ID: TEST-CASE-XXX]
- [ ] All test cases link to design with [Tests-for: DESIGN-XXX]
- [ ] Preconditions clearly stated
- [ ] Steps are actionable and specific
- [ ] Expected results are measurable
- [ ] ALWAYS use "Test Plan" terminology
```

---

### **2.6 Reviewer Templates**

**[ID: DESIGN-TEMPLATE-REVIEWERS-001] [Designs-for: PRD-FEAT-TEMPLATES-001]**

All reviewer templates follow similar structure to generators, but focus on:

1. **Completeness Check**: Are all sections present?
2. **Traceability Validation**: Do all tags exist and reference valid IDs?
3. **Quality Assessment**: Is content clear, unambiguous, testable?
4. **Consistency Check**: Does content align with upstream documents?

**Example Structure** (`templates/prompts/rd-reviewer.md`):

```markdown
# Requirements Document (RD) Reviewer

## Role
You are an independent Requirements Review expert.

## Task
Review RD.md for completeness, traceability, and quality.

## Review Checklist

### 1. Traceability Tags
- [ ] Every requirement has [ID: RD-XXX]
- [ ] All [Decomposes: XXX] references point to existing parent IDs
- [ ] No duplicate IDs

### 2. Completeness
- [ ] All requirements have clear descriptions
- [ ] All requirements have acceptance criteria
- [ ] No TODOs or placeholders

### 3. Quality
- [ ] Requirements are testable
- [ ] Requirements are unambiguous
- [ ] Requirements use consistent terminology

## Output Format
```markdown
# RD Review Report

## Summary
‚úì Overall quality: [Good/Fair/Poor]
‚ö†Ô∏è  Found [N] suggestions, [M] critical issues

## Issues

### 1. [Severity] [Section/ID]
- Location: [Section X.X]
- Issue: [Description]
- Recommendation: [Specific fix]

### 2. ...

## Traceability Check
‚úì All requirements have [ID: XXX]
‚úó Found 2 broken [Decomposes: XXX] references
```
```

---

## **‰∏â„ÄÅWorkflow Documentation Design**

### **3.1 Workflow Overview Document**

**[ID: DESIGN-WORKFLOW-OVERVIEW-001] [Designs-for: PRD-FEAT-WORKFLOWS-001]**

**File**: `templates/workflows/workflow-overview.md`

**Content Structure:**

```markdown
# SpecGovernor Workflow Overview

## 1. Introduction
SpecGovernor provides a structured SDLC workflow using Claude Code and prompt templates.

## 2. SDLC Stages

1. **RD (Requirements Document)**: Define what needs to be built
2. **PRD (Product Requirements Document)**: Define product features and user stories
3. **Design Document**: Define technical architecture and design
4. **Test Plan**: Define test strategy and cases
5. **Code**: Implement the system

## 3. Role Perspectives

As a Super Individual, you will switch between these perspectives:

- **Project Manager**: Create Epics, track overall progress
- **Requirements Analyst**: Generate and review RD
- **Product Manager**: Generate and review PRD
- **Architect**: Generate and review Design Document
- **Test Manager**: Generate and review Test Plan
- **Developer**: Implement code

## 4. General Workflow for Each Stage

### Step 1: Switch to Role Perspective
Open `.specgov/tasks/[role].md` to see assigned tasks.

### Step 2: Load Generator Prompt in Claude Code
Open Claude Code, load `.specgov/prompts/[stage]-generator.md`.

### Step 3: Provide Context
- Upstream documents (e.g., RD.md for PRD generation)
- Additional requirements or constraints

### Step 4: Generate Document
Claude Code generates the document with embedded traceability tags.

### Step 5: Review Document
Switch perspective (or use same role), load reviewer prompt, review the generated document.

### Step 6: Revise Based on Feedback
Use generator prompt again (modification mode) to address review feedback.

### Step 7: Update Task Documents
- Update your role-specific task file (`.specgov/tasks/[role].md`)
- Switch to Project Manager perspective
- Update `.specgov/tasks/project-manager.md` with Epic progress

## 5. Key Principles
- **Explicit Traceability**: Always embed tags
- **Dual Quality**: Generate + Review
- **Two-Tier Tasks**: Epic (PM) + Tasks (Roles)
- **Proper Terminology**: Design Document, Test Plan (not DD, TD)

## 6. Next Steps
See detailed workflows for each stage:
- [RD Workflow](workflow-rd.md)
- [PRD Workflow](workflow-prd.md)
- [Design Document Workflow](workflow-design.md)
- [Test Plan Workflow](workflow-test-plan.md)
```

---

### **3.2 Stage-Specific Workflows**

**[ID: DESIGN-WORKFLOW-STAGES-001] [Designs-for: PRD-FEAT-WORKFLOWS-001]**

Each stage-specific workflow (`workflow-rd.md`, `workflow-prd.md`, etc.) provides:

1. **Prerequisites**: What documents/inputs are needed
2. **Role Perspective**: Which role to switch to
3. **Step-by-Step Process**: Detailed walkthrough
4. **Examples**: Concrete examples with screenshots/code blocks
5. **Common Pitfalls**: What to avoid
6. **Checklist**: Final validation before moving to next stage

**Example** (`templates/workflows/workflow-design.md`):

```markdown
# Design Document Workflow

## Prerequisites
- ‚úÖ PRD.md completed and reviewed
- ‚úÖ RD.md available for reference
- ‚úÖ Technical constraints identified (language, framework, cloud, etc.)

## Role Perspective
Switch to **Architect** role.

## Step-by-Step Process

### Step 1: Review PRD and Technical Constraints
Open PRD.md and identify all features that need technical design.
List technical constraints (e.g., "Must use Python/FastAPI, deploy on AWS Lambda").

### Step 2: Open Claude Code and Load Prompt
1. Open Claude Code
2. Load `.specgov/prompts/design-generator.md`

### Step 3: Provide Context
Provide the following inputs to Claude Code:

**Inputs:**
- Full content of docs/PRD.md
- Full content of docs/RD.md (for reference)
- Technical constraints:
  - Programming language: Python 3.11
  - Framework: FastAPI
  - Database: PostgreSQL
  - Deployment: AWS Lambda + RDS
  - Authentication: JWT

### Step 4: Generate Design Document
Claude Code will generate Design-Document.md with:
- Architecture design [ID: DESIGN-ARCH-XXX]
- API specifications [ID: DESIGN-API-XXX]
- Database schemas [ID: DESIGN-DB-XXX]
- Each section tagged with [Designs-for: PRD-FEAT-XXX]

Save output to `docs/Design-Document.md`.

### Step 5: Review Design Document
1. Switch perspective (can stay as Architect or switch to another role for independence)
2. Load `.specgov/prompts/design-reviewer.md` in Claude Code
3. Provide docs/Design-Document.md for review
4. Claude Code outputs review report

### Step 6: Address Review Feedback
If review identifies issues:
1. Load `.specgov/prompts/design-generator.md` again
2. Provide existing Design-Document.md + review feedback
3. Claude Code modifies the document
4. Repeat review if needed

### Step 7: Update Task Documents
1. Open `.specgov/tasks/architect.md`
2. Mark Design Document generation task as complete
3. Add notes on key design decisions
4. Switch to Project Manager perspective
5. Open `.specgov/tasks/project-manager.md`
6. Update Epic progress (e.g., 60% ‚Üí 80%)
7. Commit both files to Git

## Example Output

## 2. API Design

### 2.1 OAuth2 Callback Endpoint
**[ID: DESIGN-API-008] [Designs-for: PRD-FEAT-012]**

**Endpoint**: POST /auth/oauth2/callback

**Request:**
```json
{
  "provider": "google",
  "code": "4/0AY0e-g7...",
  "redirect_uri": "https://app.example.com/callback"
}
```

**Response (Success):**
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh_token": "def50200...",
  "expires_in": 3600,
  "user": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "email": "john.doe@gmail.com",
    "name": "John Doe",
    "avatar": "https://lh3.googleusercontent.com/..."
  }
}
```

**Implementation:**
1. Validate provider (google/github/microsoft)
2. Exchange authorization code for access token via provider's OAuth2 API
3. Fetch user profile from provider
4. Create or update user in PostgreSQL users table
5. Generate JWT access_token and refresh_token
6. Return tokens and user info

## Common Pitfalls
- ‚ùå Forgetting to add [Designs-for: PRD-XXX] tags
- ‚ùå Using "DD" instead of "Design Document"
- ‚ùå Not providing enough detail in API specs (missing error responses)
- ‚ùå Designing without considering deployment constraints

## Validation Checklist
Before moving to Test Plan stage:
- [ ] All designs have [ID: DESIGN-XXX] tags
- [ ] All designs link to PRD with [Designs-for: PRD-XXX]
- [ ] API specs include request, response (success + error), and implementation notes
- [ ] Database schemas show all fields, indexes, relationships
- [ ] Architecture aligns with technical constraints
- [ ] Review completed and feedback addressed
- [ ] Task documents updated (architect.md + project-manager.md)
- [ ] Changes committed to Git
```

---

## **Âõõ„ÄÅHelper Scripts Design**

### **4.1 Project Initialization Script**

**[ID: DESIGN-SCRIPT-INIT-001] [Designs-for: PRD-FEAT-SCRIPTS-001]**

**File**: `scripts/init_project.py`

**Purpose**: Initialize SpecGovernor structure for user's project

**Algorithm:**

```python
#!/usr/bin/env python3
"""
Initialize SpecGovernor project structure.
"""
import os
import json
import shutil
from datetime import datetime

def prompt_project_size():
    """Prompt user to select project size."""
    print("ËØ∑ÈÄâÊã©È°πÁõÆËßÑÊ®°Ôºö")
    print("1. Â∞èÈ°πÁõÆÔºà< 10 ‰∏áË°å‰ª£Á†ÅÔºåÂçïÂ±ÇÊñáÊ°£ÁªìÊûÑÔºâ")
    print("2. Â§ßÈ°πÁõÆÔºà‚â• 10 ‰∏áË°å‰ª£Á†ÅÔºåÂèåÂ±ÇÊñáÊ°£ÁªìÊûÑÔºâ")

    while True:
        choice = input("ÊÇ®ÁöÑÈÄâÊã© (1/2): ").strip()
        if choice in ['1', '2']:
            return 'small' if choice == '1' else 'large'
        print("Êó†ÊïàÈÄâÊã©ÔºåËØ∑ËæìÂÖ• 1 Êàñ 2")

def create_directory_structure(project_size):
    """Create directory structure based on project size."""
    # Create .specgov/ directory
    os.makedirs('.specgov', exist_ok=True)
    os.makedirs('.specgov/prompts', exist_ok=True)
    os.makedirs('.specgov/workflows', exist_ok=True)
    os.makedirs('.specgov/tasks', exist_ok=True)
    os.makedirs('.specgov/index', exist_ok=True)

    # Copy prompts from templates/
    shutil.copytree('templates/prompts', '.specgov/prompts', dirs_exist_ok=True)
    shutil.copytree('templates/workflows', '.specgov/workflows', dirs_exist_ok=True)

    # Create task files
    task_files = [
        'project-manager.md',
        'rd-analyst.md',
        'product-manager.md',
        'architect.md',
        'test-manager.md'
    ]
    for task_file in task_files:
        create_task_file(f'.specgov/tasks/{task_file}')

    # Create docs/ structure
    if project_size == 'small':
        os.makedirs('docs', exist_ok=True)
        create_placeholder('docs/RD.md', 'Requirements Document')
        create_placeholder('docs/PRD.md', 'Product Requirements Document')
        create_placeholder('docs/Design-Document.md', 'Design Document')
        create_placeholder('docs/Test-Plan.md', 'Test Plan')
    else:  # large
        os.makedirs('docs/RD', exist_ok=True)
        os.makedirs('docs/PRD', exist_ok=True)
        os.makedirs('docs/Design-Document', exist_ok=True)
        os.makedirs('docs/Test-Plan', exist_ok=True)
        create_placeholder('docs/RD/RD-Overview.md', 'Requirements Overview')
        create_placeholder('docs/PRD/PRD-Overview.md', 'Product Overview')
        create_placeholder('docs/Design-Document/Design-Overview.md', 'Design Overview')
        create_placeholder('docs/Test-Plan/Test-Overview.md', 'Test Overview')

    # Create project config
    config = {
        "project_name": os.path.basename(os.getcwd()),
        "project_size": project_size,
        "document_structure": "single-tier" if project_size == 'small' else "two-tier",
        "created_at": datetime.now().isoformat(),
        "modules": []
    }
    with open('.specgov/project-config.json', 'w') as f:
        json.dump(config, f, indent=2)

def create_task_file(filepath):
    """Create empty task file with header."""
    role_name = os.path.basename(filepath).replace('.md', '').replace('-', ' ').title()
    content = f"""# {role_name} Tasks

## Active Tasks
(No tasks assigned yet)

## Completed Tasks
(No tasks completed yet)
"""
    with open(filepath, 'w') as f:
        f.write(content)

def create_placeholder(filepath, doc_type):
    """Create placeholder document."""
    content = f"""# {doc_type}

> **Version**: 1.0
> **Created**: {datetime.now().strftime('%Y-%m-%d')}

(This document will be generated using SpecGovernor prompt templates)
"""
    with open(filepath, 'w') as f:
        f.write(content)

def main():
    print("SpecGovernor Project Initialization")
    print("=" * 50)

    project_size = prompt_project_size()
    print(f"\nÊ≠£Âú®ÂàõÂª∫ {project_size} È°πÁõÆÁªìÊûÑ...")

    create_directory_structure(project_size)

    print("\n‚úì SpecGovernor È°πÁõÆÁªìÊûÑÂàõÂª∫ÂÆåÊàê")
    print("\nüìö ‰∏ã‰∏ÄÊ≠•Ôºö")
    print("  1. Review .specgov/workflows/workflow-overview.md")
    print("  2. As Project Manager, create your first Epic in .specgov/tasks/project-manager.md")
    print("  3. Switch to Requirements Analyst role, load .specgov/prompts/rd-generator.md in Claude Code")

if __name__ == '__main__':
    main()
```

---

### **4.2 Tag Parser Script**

**[ID: DESIGN-SCRIPT-PARSER-001] [Designs-for: PRD-FEAT-SCRIPTS-001]**

**File**: `scripts/parse_tags.py`

**Purpose**: Parse traceability tags from all files

**Algorithm:**

```python
#!/usr/bin/env python3
"""
Parse traceability tags from Markdown and code files.
"""
import os
import re
import json
from pathlib import Path

TAG_PATTERNS = {
    'id': r'\[ID:\s*([A-Z0-9-]+)\]',
    'implements': r'\[Implements:\s*([A-Z0-9-]+)\]',
    'decomposes': r'\[Decomposes:\s*([A-Z0-9-]+)\]',
    'designs_for': r'\[Designs-for:\s*([A-Z0-9-]+)\]',
    'tests_for': r'\[Tests-for:\s*([A-Z0-9-]+)\]',
    'module': r'\[Module:\s*([A-Za-z0-9-]+)\]'
}

def scan_files(root_dirs=['docs', 'src']):
    """Scan all Markdown and code files."""
    files = []
    for root_dir in root_dirs:
        if not os.path.exists(root_dir):
            continue
        for filepath in Path(root_dir).rglob('*'):
            if filepath.is_file() and (
                filepath.suffix in ['.md', '.py', '.ts', '.tsx', '.js', '.jsx', '.java', '.go']
            ):
                files.append(str(filepath))
    return files

def parse_file(filepath):
    """Parse traceability tags from a single file."""
    tags = []

    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                # Find ID tag
                id_match = re.search(TAG_PATTERNS['id'], line)
                if id_match:
                    tag_id = id_match.group(1)
                    tag_entry = {
                        'id': tag_id,
                        'file': filepath,
                        'line': line_num,
                        'type': infer_type(tag_id)
                    }

                    # Find relationship tags on same line
                    for rel_type, pattern in TAG_PATTERNS.items():
                        if rel_type in ['id', 'module']:
                            continue
                        match = re.search(pattern, line)
                        if match:
                            tag_entry[rel_type] = match.group(1)

                    # Find module tag
                    module_match = re.search(TAG_PATTERNS['module'], line)
                    if module_match:
                        tag_entry['module'] = module_match.group(1)

                    tags.append(tag_entry)
    except Exception as e:
        print(f"Error reading {filepath}: {e}")

    return tags

def infer_type(tag_id):
    """Infer tag type from ID prefix."""
    if tag_id.startswith('RD-'):
        return 'requirement'
    elif tag_id.startswith('PRD-FEAT-'):
        return 'feature'
    elif tag_id.startswith('PRD-US-'):
        return 'user_story'
    elif tag_id.startswith('DESIGN-ARCH-'):
        return 'architecture'
    elif tag_id.startswith('DESIGN-API-'):
        return 'api_design'
    elif tag_id.startswith('DESIGN-DB-'):
        return 'database_design'
    elif tag_id.startswith('TEST-CASE-'):
        return 'test_case'
    elif tag_id.startswith('CODE-'):
        return 'code'
    else:
        return 'unknown'

def main():
    print("Parsing traceability tags...")

    files = scan_files()
    print(f"‚úì Scanning {len(files)} files")

    all_tags = []
    for filepath in files:
        tags = parse_file(filepath)
        all_tags.extend(tags)

    # Count tags
    id_count = len(all_tags)
    implements_count = sum(1 for t in all_tags if 'implements' in t)
    decomposes_count = sum(1 for t in all_tags if 'decomposes' in t)
    designs_for_count = sum(1 for t in all_tags if 'designs_for' in t)
    tests_for_count = sum(1 for t in all_tags if 'tests_for' in t)

    # Save to JSON
    output = {'tags': all_tags}
    os.makedirs('.specgov/index', exist_ok=True)
    with open('.specgov/index/tags.json', 'w') as f:
        json.dump(output, f, indent=2)

    print(f"‚úì Found {id_count} [ID: XXX] tags")
    print(f"‚úì Found {implements_count} [Implements: XXX] tags")
    print(f"‚úì Found {decomposes_count} [Decomposes: XXX] tags")
    print(f"‚úì Found {designs_for_count} [Designs-for: XXX] tags")
    print(f"‚úì Found {tests_for_count} [Tests-for: XXX] tags")
    print(f"‚úì Saved to .specgov/index/tags.json")

if __name__ == '__main__':
    main()
```

---

### **4.3 Dependency Graph Builder Script**

**[ID: DESIGN-SCRIPT-GRAPH-001] [Designs-for: PRD-FEAT-SCRIPTS-001]**

**File**: `scripts/build_graph.py`

**Purpose**: Build dependency graph from parsed tags

**Algorithm:**

```python
#!/usr/bin/env python3
"""
Build dependency graph from parsed tags.
"""
import json
import os

def load_tags():
    """Load tags from tags.json."""
    with open('.specgov/index/tags.json', 'r') as f:
        data = json.load(f)
    return data['tags']

def build_graph(tags):
    """Build dependency graph from tags."""
    nodes = []
    edges = []

    # Create nodes
    for tag in tags:
        node = {
            'id': tag['id'],
            'type': tag['type'],
            'location': f"{tag['file']}#L{tag['line']}"
        }
        if 'module' in tag:
            node['module'] = tag['module']
        nodes.append(node)

    # Create edges
    for tag in tags:
        source_id = tag['id']

        # Implements relationship
        if 'implements' in tag:
            edges.append({
                'from': source_id,
                'to': tag['implements'],
                'relation': 'implements'
            })

        # Decomposes relationship
        if 'decomposes' in tag:
            edges.append({
                'from': source_id,
                'to': tag['decomposes'],
                'relation': 'decomposes'
            })

        # Designs-for relationship
        if 'designs_for' in tag:
            edges.append({
                'from': source_id,
                'to': tag['designs_for'],
                'relation': 'designs-for'
            })

        # Tests-for relationship
        if 'tests_for' in tag:
            edges.append({
                'from': source_id,
                'to': tag['tests_for'],
                'relation': 'tests-for'
            })

    return {'nodes': nodes, 'edges': edges}

def detect_circular_dependencies(graph):
    """Detect circular dependencies using DFS."""
    # Build adjacency list
    adj = {}
    for edge in graph['edges']:
        if edge['from'] not in adj:
            adj[edge['from']] = []
        adj[edge['from']].append(edge['to'])

    visited = set()
    rec_stack = set()
    cycles = []

    def dfs(node, path):
        visited.add(node)
        rec_stack.add(node)

        if node in adj:
            for neighbor in adj[node]:
                if neighbor not in visited:
                    dfs(neighbor, path + [neighbor])
                elif neighbor in rec_stack:
                    # Found cycle
                    cycle_start = path.index(neighbor)
                    cycles.append(path[cycle_start:] + [neighbor])

        rec_stack.remove(node)

    for node_data in graph['nodes']:
        node = node_data['id']
        if node not in visited:
            dfs(node, [node])

    return cycles

def count_by_type(graph):
    """Count nodes by type."""
    counts = {}
    for node in graph['nodes']:
        node_type = node['type']
        counts[node_type] = counts.get(node_type, 0) + 1
    return counts

def main():
    print("Building dependency graph...")

    tags = load_tags()
    graph = build_graph(tags)

    print(f"‚úì Created {len(graph['nodes'])} nodes")
    print(f"‚úì Created {len(graph['edges'])} edges")

    # Detect circular dependencies
    cycles = detect_circular_dependencies(graph)
    if cycles:
        print(f"‚ö†Ô∏è  Detected {len(cycles)} circular dependencies:")
        for cycle in cycles:
            print(f"   {' ‚Üí '.join(cycle)}")
    else:
        print("‚úì Detected 0 circular dependencies")

    # Save graph
    with open('.specgov/index/dependency-graph.json', 'w') as f:
        json.dump(graph, f, indent=2)
    print("‚úì Saved to .specgov/index/dependency-graph.json")

    # Statistics
    counts = count_by_type(graph)
    print("\nüìä Statistics:")
    for node_type, count in sorted(counts.items()):
        print(f"  - {node_type}: {count}")

if __name__ == '__main__':
    main()
```

---

### **4.4 Impact Analysis Script**

**[ID: DESIGN-SCRIPT-IMPACT-001] [Designs-for: PRD-FEAT-SCRIPTS-001]**

**File**: `scripts/impact_analysis.py`

**Purpose**: Analyze impact of file changes

**Algorithm:**

```python
#!/usr/bin/env python3
"""
Analyze impact of file changes using git diff and dependency graph.
"""
import json
import subprocess
import argparse
import re

TAG_PATTERN = r'\[ID:\s*([A-Z0-9-]+)\]'

def get_changed_lines(filepath):
    """Get changed line numbers using git diff."""
    try:
        result = subprocess.run(
            ['git', 'diff', 'HEAD', filepath],
            capture_output=True,
            text=True
        )
        diff = result.stdout

        # Parse diff to find changed lines
        changed_lines = []
        current_line = 0
        for line in diff.split('\n'):
            if line.startswith('@@'):
                # Extract line number from @@ -a,b +c,d @@
                match = re.search(r'\+(\d+)', line)
                if match:
                    current_line = int(match.group(1))
            elif line.startswith('+') and not line.startswith('+++'):
                changed_lines.append(current_line)
                current_line += 1
            elif not line.startswith('-'):
                current_line += 1

        return changed_lines
    except Exception as e:
        print(f"Error running git diff: {e}")
        return []

def find_changed_tags(filepath, changed_lines):
    """Find tags in changed lines."""
    changed_tags = []

    try:
        with open(filepath, 'r') as f:
            for line_num, line in enumerate(f, 1):
                if line_num in changed_lines:
                    match = re.search(TAG_PATTERN, line)
                    if match:
                        changed_tags.append(match.group(1))
    except Exception as e:
        print(f"Error reading file: {e}")

    return changed_tags

def load_graph():
    """Load dependency graph."""
    with open('.specgov/index/dependency-graph.json', 'r') as f:
        return json.load(f)

def find_downstream(graph, source_ids):
    """Find all downstream nodes (BFS)."""
    # Build adjacency list (reverse direction for downstream)
    adj = {}
    for edge in graph['edges']:
        # Downstream: if A implements B, then B affects A
        target = edge['from']
        source = edge['to']
        if source not in adj:
            adj[source] = []
        adj[source].append((target, edge['relation']))

    # BFS from source_ids
    queue = [(sid, None) for sid in source_ids]
    visited = set(source_ids)
    affected = []

    while queue:
        node_id, reason = queue.pop(0)

        if node_id in adj:
            for neighbor, relation in adj[node_id]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    affected.append((neighbor, f"{relation.capitalize()} {node_id}"))
                    queue.append((neighbor, f"{relation} {node_id}"))

    return affected

def get_node_info(graph, node_id):
    """Get node information."""
    for node in graph['nodes']:
        if node['id'] == node_id:
            return node
    return None

def main():
    parser = argparse.ArgumentParser(description='Analyze impact of file changes')
    parser.add_argument('--changed', required=True, help='Changed file path')
    args = parser.parse_args()

    print("üîç Analyzing impact...")

    # Get changed lines
    changed_lines = get_changed_lines(args.changed)
    if not changed_lines:
        print(f"No changes detected in {args.changed}")
        return

    # Find changed tags
    changed_tags = find_changed_tags(args.changed, changed_lines)
    if not changed_tags:
        print("No traceability tags found in changed lines")
        return

    # Load graph
    graph = load_graph()

    # Find downstream nodes
    affected = find_downstream(graph, changed_tags)

    # Print report
    print("\n" + "‚îÅ" * 50)
    print("üìä Impact Analysis Report")
    print("‚îÅ" * 50)

    print(f"\nChanged Nodes ({len(changed_tags)}):")
    for tag_id in changed_tags:
        node = get_node_info(graph, tag_id)
        if node:
            print(f"  ‚Ä¢ {tag_id} ({node['type']}) at {node['location']}")

    print(f"\nAffected Nodes ({len(affected)}):")
    for node_id, reason in affected:
        node = get_node_info(graph, node_id)
        if node:
            print(f"  ‚ö†Ô∏è  {node_id} ({node['type']}) at {node['location']}")
            print(f"      Reason: {reason}")

    print("\nRecommended Actions:")
    print("  1. Review and update affected documents")
    print("  2. Run tests for affected code")
    print("  3. Update dependency graph (python scripts/parse_tags.py && python scripts/build_graph.py)")

    print("\n" + "‚îÅ" * 50)
    print(f"\n‚è±Ô∏è  Time: < 10 seconds")
    print("üí∞ Cost: $0 (graph query only)")

if __name__ == '__main__':
    main()
```

---

## **‰∫î„ÄÅNon-Functional Requirements**

### **5.1 Performance**

**[ID: DESIGN-NFR-PERF-001] [Designs-for: PRD-NFR-002]**

| Operation | Target | Implementation Strategy |
|-----------|--------|------------------------|
| Tag parsing | < 1 min for 100K LOC | Use regex, scan files in parallel (Python multiprocessing) |
| Graph building | < 1 min for 100K LOC | In-memory graph construction, simple adjacency list |
| Impact analysis | < 10 seconds | Graph query using BFS, no AI calls |
| Project initialization | < 5 seconds | Simple file/directory creation |

---

### **5.2 Cost**

**[ID: DESIGN-NFR-COST-001] [Designs-for: PRD-NFR-003]**

| Component | Cost | Rationale |
|-----------|------|-----------|
| Helper scripts | $0 | Pure Python, local execution, no external APIs |
| Prompt templates | $0 | Just markdown files |
| Using templates with Claude | User's Claude API cost | User pays for their own Claude Code usage |

---

### **5.3 Maintainability**

**[ID: DESIGN-NFR-MAINT-001] [Designs-for: PRD-NFR-004]**

- All templates: Plain markdown (no proprietary format)
- All scripts: Python 3.8+ with standard library only
- No external dependencies for core functionality
- Git-trackable: All changes versioned
- Extensible: Users can edit templates, add custom scripts

---

## **ÂÖ≠„ÄÅSummary**

### **6.1 Deliverables**

**[ID: DESIGN-SUMMARY-001]**

Based on this Design Document, the following will be implemented:

1. **Prompt Templates** (9+ markdown files in `templates/prompts/`)
   - rd-generator.md, rd-reviewer.md
   - prd-generator.md, prd-reviewer.md
   - design-generator.md, design-reviewer.md
   - test-plan-generator.md, test-plan-reviewer.md
   - code-generator.md
   - Large project variants (overview/module generators)

2. **Workflow Documentation** (7 markdown files in `templates/workflows/`)
   - workflow-overview.md
   - workflow-rd.md, workflow-prd.md, workflow-design.md, workflow-test-plan.md
   - workflow-task-mgmt.md
   - workflow-large-project.md

3. **Helper Scripts** (4 Python files in `scripts/`)
   - init_project.py
   - parse_tags.py
   - build_graph.py
   - impact_analysis.py

---

### **6.2 Next Steps**

**[ID: DESIGN-NEXT-001]**

1. ‚úÖ **Write Test Plan**: Test strategy for all components
2. ‚úÖ **Implement Prompt Templates**: Create all .md files with detailed prompts
3. ‚úÖ **Implement Workflow Docs**: Write step-by-step guides
4. ‚úÖ **Implement Python Scripts**: Develop and test all helper scripts
5. ‚úÖ **Integration Testing**: Test complete workflow end-to-end

---

**Design Document Complete**
